> 记录一个iOS面试题，有关多线程的算法题

# 问题：有两个线程，一个线程打印奇数另一个打印偶数，它们交替输出1-100

如果之前没有碰到过这个问题，首次遇到可能会有些懵懵的情况，下边给出分析和答案
首先一个确定的是，打印数值，需要有一个全局变量或成员变量current，来标记输出的数值。两个线程可以可以使用`GCD`的`dispatch_async`方法。再维护一个全局的并发队列或两个串行队列都可以来实现。在异步方法里要使用锁或信号量来维持顺序执行
示例代码如下：

```

#import "ViewController.h"

@interface ViewController ()
@property (nonatomic, assign) int current;
@property (nonatomic, strong) dispatch_semaphore_t oddSemaphore;
@property (nonatomic, strong) dispatch_semaphore_t evenSemaphore;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.current = 1;
    self.oddSemaphore = dispatch_semaphore_create(1);   // 奇数线程先执行
    self.evenSemaphore = dispatch_semaphore_create(0);  // 偶数线程等待
    
    // 使用一个并发队列
   dispatch_queue_t concurrentQueue = dispatch_queue_create("concurrent.queue", DISPATCH_QUEUE_CONCURRENT);
   
   dispatch_async(concurrentQueue, ^{
       [self printOdd];
   });
   
   dispatch_async(concurrentQueue, ^{
       [self printEven];
   });
    
    
}

- (void)printOdd {
    while (self.current <= 100) {
        dispatch_semaphore_wait(self.oddSemaphore, DISPATCH_TIME_FOREVER);
        
        if (self.current <= 100) {//这个要是不写的话，会打印101，因为进来是小于100的，等偶数的100打印后，会增加oddSemaphore信号。这个还会进进来一次，所以会打印101。
            NSLog(@"奇数线程: %d %@", self.current,[NSThread currentThread]);
            self.current++;
        }
        
        dispatch_semaphore_signal(self.evenSemaphore);
    }
}

- (void)printEven {
    
    while (self.current <= 100) {
        dispatch_semaphore_wait(self.evenSemaphore, DISPATCH_TIME_FOREVER);
        
        if (self.current <= 100) {
            NSLog(@"偶数线程: %d, %@", self.current,[NSThread currentThread]);
            self.current++;
        }
        
        dispatch_semaphore_signal(self.oddSemaphore);
    }
}
@end
```
运行一下代码，看下输出结果也是对的。

